substitutions:
  ma_host: "192.168.0.157"
  ma_port: "8095"
  ma_token: "z4lw6YU4SocmbYnwcRBm5XTRzbBvT7BrvkZauBeC7ApGCrG0Y_aGzYYMtsr23fmY"
  ma_player: "ma_room_kueche"

esphome:
  name: linda-audiobook-controller
  friendly_name: "Linda's Audiobook Controller"
  platformio_options:
    board_build.flash_mode: qio
    board_build.psram_type: opi
  on_boot:
    priority: 600
    then:
      - switch.turn_on: lcd_power_switch
      - switch.turn_on: backlight_power_switch
      - delay: 100ms
      - switch.turn_on: backlight
      - logger.log: "Display power enabled"
      - delay: 500ms
      - script.execute: led_idle
      - script.execute: update_home_display
      - wait_until:
          wifi.connected:
      - logger.log: "WiFi connected, fetching artists..."
      - delay: 2000ms
      - script.execute: fetch_artists

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: esp-idf
    version: recommended
  flash_size: 16MB

psram:
  mode: octal
  speed: 80MHz

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true

  ap:
    ssid: "Linda-Controller-AP"
    password: !secret ap_password

captive_portal:

api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

logger:
  level: DEBUG

# ============================================
# Music Assistant Configuration
# ============================================

http_request:
  useragent: esphome/linda-controller
  timeout: 10s
  verify_ssl: false

# ============================================
# Hardware Configuration
# ============================================

# SPI Bus for Display
spi:
  clk_pin: GPIO10
  mosi_pin: GPIO11

# I2C Bus for Touch
i2c:
  - id: bus_touch
    sda: GPIO6
    scl: GPIO7
    scan: false

# Power rails - CRITICAL for CrowPanel!
output:
  - platform: gpio
    id: lcd_power
    pin: GPIO1

  - platform: gpio
    id: backlight_power
    pin: GPIO2

  - platform: gpio
    id: backlight_pwm
    pin: GPIO46

switch:
  - platform: output
    id: lcd_power_switch
    name: "LCD Power"
    output: lcd_power
    restore_mode: ALWAYS_ON
    internal: true

  - platform: output
    id: backlight_power_switch
    name: "Backlight Power"
    output: backlight_power
    restore_mode: ALWAYS_ON
    internal: true

  - platform: output
    id: backlight
    name: "Display Backlight"
    output: backlight_pwm
    restore_mode: ALWAYS_ON
    internal: true

# RGB LEDs
light:
  - platform: esp32_rmt_led_strip
    id: rgb_leds
    rgb_order: GRB
    chipset: WS2812
    pin: GPIO48
    num_leds: 5
    name: "Status LEDs"
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
      - pulse:
          name: "Playing Pulse"
          transition_length: 1s
          update_interval: 1s
          min_brightness: 30%
          max_brightness: 100%
      - strobe:
          name: "Error"
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 500ms
            - state: false
              duration: 500ms

# ============================================
# Global State and Data Storage
# ============================================
globals:
  - id: current_screen
    type: int
    initial_value: "0"  # 0=HOME, 1=ALBUMS, 2=PLAYING
  - id: selected_artist
    type: int
    initial_value: "0"
  - id: selected_album
    type: int
    initial_value: "0"
  - id: current_volume
    type: int
    initial_value: "50"
  - id: is_playing
    type: bool
    initial_value: "false"
  - id: artist_count
    type: int
    initial_value: "0"
  - id: album_count
    type: int
    initial_value: "0"
  # Artist data (max 10 artists)
  - id: artist_names
    type: std::vector<std::string>
  - id: artist_ids
    type: std::vector<std::string>
  # Album data for current artist (max 20 albums)
  - id: album_names
    type: std::vector<std::string>
  - id: album_ids
    type: std::vector<std::string>
  - id: album_uris
    type: std::vector<std::string>
  - id: album_artist_ids
    type: std::vector<std::string>
  # Filtered albums for current artist
  - id: filtered_album_names
    type: std::vector<std::string>
  - id: filtered_album_ids
    type: std::vector<std::string>
  - id: filtered_album_uris
    type: std::vector<std::string>
  # HTTP request body storage
  - id: request_body
    type: std::string

# Rotary Encoder
sensor:
  - platform: rotary_encoder
    id: dial
    name: "Dial Position"
    pin_a: GPIO45
    pin_b: GPIO42
    resolution: 1
    on_clockwise:
      - lambda: |-
          int screen = id(current_screen);
          if (screen == 0) {
            // HOME: next artist
            if (id(artist_count) > 0) {
              id(selected_artist) = (id(selected_artist) + 1) % id(artist_count);
            }
            ESP_LOGI("nav", "Artist: %d", id(selected_artist));
          } else if (screen == 1) {
            // ALBUMS: next album
            if (id(album_count) > 0) {
              id(selected_album) = (id(selected_album) + 1) % id(album_count);
            }
            ESP_LOGI("nav", "Album: %d", id(selected_album));
          } else if (screen == 2) {
            // PLAYING: volume up
            id(current_volume) = std::min(id(current_volume) + 5, 100);
            ESP_LOGI("nav", "Volume: %d", id(current_volume));
          }
      - script.execute: update_display
      - if:
          condition:
            lambda: 'return id(current_screen) == 2;'
          then:
            - script.execute: ma_set_volume
            - script.execute: led_show_volume
          else:
            - script.execute: led_show_position
    on_anticlockwise:
      - lambda: |-
          int screen = id(current_screen);
          if (screen == 0) {
            // HOME: previous artist
            if (id(artist_count) > 0) {
              id(selected_artist) = (id(selected_artist) + id(artist_count) - 1) % id(artist_count);
            }
            ESP_LOGI("nav", "Artist: %d", id(selected_artist));
          } else if (screen == 1) {
            // ALBUMS: previous album
            if (id(album_count) > 0) {
              id(selected_album) = (id(selected_album) + id(album_count) - 1) % id(album_count);
            }
            ESP_LOGI("nav", "Album: %d", id(selected_album));
          } else if (screen == 2) {
            // PLAYING: volume down
            id(current_volume) = std::max(id(current_volume) - 5, 0);
            ESP_LOGI("nav", "Volume: %d", id(current_volume));
          }
      - script.execute: update_display
      - if:
          condition:
            lambda: 'return id(current_screen) == 2;'
          then:
            - script.execute: ma_set_volume
            - script.execute: led_show_volume
          else:
            - script.execute: led_show_position

# Encoder Button
binary_sensor:
  - platform: gpio
    id: dial_button
    name: "Dial Button"
    pin:
      number: GPIO41
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_click:
      min_length: 0ms
      max_length: 350ms
      then:
        - lambda: |-
            int screen = id(current_screen);
            if (screen == 0) {
              // HOME: Click opens albums for artist
              id(current_screen) = 1;
              id(selected_album) = 0;
              ESP_LOGI("nav", "HOME -> ALBUMS");
            } else if (screen == 1) {
              // ALBUMS: Click plays album
              id(current_screen) = 2;
              id(is_playing) = true;
              ESP_LOGI("nav", "ALBUMS -> PLAYING");
            } else if (screen == 2) {
              // PLAYING: Click toggles play/pause
              id(is_playing) = !id(is_playing);
              ESP_LOGI("nav", "Play/Pause: %s", id(is_playing) ? "playing" : "paused");
            }
        - if:
            condition:
              lambda: 'return id(current_screen) == 1;'
            then:
              - script.execute: fetch_albums
        - script.execute: update_display
        - if:
            condition:
              lambda: 'return id(current_screen) == 2 && id(is_playing);'
            then:
              - script.execute: ma_play_album
              - script.execute: led_playing
        - if:
            condition:
              lambda: 'return id(current_screen) == 2 && !id(is_playing);'
            then:
              - script.execute: ma_pause
              - script.execute: led_paused
    on_double_click:
      min_length: 50ms
      max_length: 350ms
      then:
        - lambda: |-
            int screen = id(current_screen);
            if (screen == 1) {
              // ALBUMS: Double-click goes back to HOME
              id(current_screen) = 0;
              ESP_LOGI("nav", "ALBUMS -> HOME");
            } else if (screen == 2) {
              // PLAYING: Double-click goes back to ALBUMS
              id(current_screen) = 1;
              ESP_LOGI("nav", "PLAYING -> ALBUMS");
            }
        - script.execute: update_display
    on_multi_click:
      - timing:
          - ON for at least 2s
        then:
          - lambda: |-
              if (id(current_screen) == 2) {
                // PLAYING: Long press stops and goes HOME
                id(is_playing) = false;
                id(current_screen) = 0;
                ESP_LOGI("nav", "STOP -> HOME");
              }
          - script.execute: ma_stop
          - script.execute: update_display
          - script.execute: led_idle

# ============================================
# Scripts
# ============================================
script:
  # Fetch albums and extract unique artists (so we only show artists with albums)
  - id: fetch_artists
    then:
      - logger.log: "Starting fetch_artists (from albums)..."
      - lambda: |-
          id(artist_names).clear();
          id(artist_ids).clear();
          id(album_names).clear();
          id(album_ids).clear();
          id(album_uris).clear();
          id(album_artist_ids).clear();
          ESP_LOGI("ma", "Fetching all albums to extract artists...");
      - http_request.post:
          url: "http://${ma_host}:${ma_port}/api"
          capture_response: true
          max_response_buffer_size: 65536
          request_headers:
            Content-Type: "application/json"
            Authorization: "Bearer ${ma_token}"
          body: '{"command":"music/albums/library_items","args":{"limit":100}}'
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("ma", "Got albums response: status=%d, len=%d", response->status_code, body.length());
                  if (response->status_code == 200 && body.length() > 2) {
                    JsonDocument doc;
                    DeserializationError error = deserializeJson(doc, body);

                    if (error) {
                      ESP_LOGW("ma", "Initial parse failed: %s, trying fix...", error.c_str());
                      std::string json_str = body;
                      size_t last_complete = json_str.rfind("},{");
                      if (last_complete != std::string::npos) {
                        json_str = json_str.substr(0, last_complete + 1) + "]";
                        error = deserializeJson(doc, json_str);
                      }
                    }

                    if (error) {
                      ESP_LOGE("ma", "JSON parse error: %s", error.c_str());
                    } else if (doc.is<JsonArray>()) {
                      JsonArray arr = doc.as<JsonArray>();
                      ESP_LOGI("ma", "Parsed %d albums", arr.size());

                      // Store all albums with their artist IDs
                      for (JsonObject album : arr) {
                        const char* name = album["name"] | "Unknown";
                        const char* item_id = album["item_id"] | "0";
                        const char* uri = album["uri"] | "";

                        // Extract first artist from each album
                        JsonArray artists = album["artists"];
                        std::string album_artist_id = "0";
                        if (artists.size() > 0) {
                          JsonObject artist = artists[0];
                          const char* artist_name = artist["name"] | "Unknown";
                          const char* artist_id = artist["item_id"] | "0";
                          album_artist_id = std::string(artist_id);

                          // Check if we already have this artist in our list
                          bool found = false;
                          for (const auto& existing_id : id(artist_ids)) {
                            if (existing_id == album_artist_id) {
                              found = true;
                              break;
                            }
                          }
                          if (!found && id(artist_names).size() < 20) {
                            id(artist_names).push_back(std::string(artist_name));
                            id(artist_ids).push_back(album_artist_id);
                            ESP_LOGD("ma", "Found artist: %s (id=%s)", artist_name, artist_id);
                          }
                        }

                        // Store album with its artist ID
                        id(album_names).push_back(std::string(name));
                        id(album_ids).push_back(std::string(item_id));
                        id(album_uris).push_back(std::string(uri));
                        id(album_artist_ids).push_back(album_artist_id);
                      }
                      id(artist_count) = id(artist_names).size();
                      id(album_count) = id(album_names).size();
                      ESP_LOGI("ma", "Total: %d unique artists, %d albums", id(artist_count), id(album_count));
                    }
                  } else {
                    ESP_LOGE("ma", "HTTP error: %d", response->status_code);
                  }
      - logger.log: "fetch_artists script complete"
      - script.execute: update_home_display

  # Filter albums for current artist (from already-loaded data)
  - id: fetch_albums
    then:
      - lambda: |-
          // Clear filtered lists
          id(filtered_album_names).clear();
          id(filtered_album_ids).clear();
          id(filtered_album_uris).clear();

          // Get selected artist ID
          std::string target_artist_id = "";
          std::string target_artist_name = "";
          if (id(selected_artist) < id(artist_ids).size()) {
            target_artist_id = id(artist_ids)[id(selected_artist)];
            target_artist_name = id(artist_names)[id(selected_artist)];
          }
          ESP_LOGI("ma", "Filtering albums for artist: %s (id=%s)", target_artist_name.c_str(), target_artist_id.c_str());

          // Filter albums by artist ID
          int count = 0;
          for (size_t i = 0; i < id(album_names).size() && count < 20; i++) {
            if (id(album_artist_ids)[i] == target_artist_id) {
              id(filtered_album_names).push_back(id(album_names)[i]);
              id(filtered_album_ids).push_back(id(album_ids)[i]);
              id(filtered_album_uris).push_back(id(album_uris)[i]);
              count++;
            }
          }
          id(album_count) = count;
          ESP_LOGI("ma", "Filtered %d albums for %s", count, target_artist_name.c_str());
      - script.execute: update_album_display

  # Update display based on current screen
  - id: update_display
    then:
      - if:
          condition:
            lambda: 'return id(current_screen) == 0;'
          then:
            - lvgl.page.show: page_home
            - script.execute: update_home_display
      - if:
          condition:
            lambda: 'return id(current_screen) == 1;'
          then:
            - lvgl.page.show: page_albums
            - script.execute: update_album_display
      - if:
          condition:
            lambda: 'return id(current_screen) == 2;'
          then:
            - lvgl.page.show: page_player
            - lvgl.arc.update:
                id: volume_arc
                value: !lambda 'return id(current_volume);'
            - script.execute: update_player_display

  # Update HOME screen with current artist
  - id: update_home_display
    then:
      - lvgl.label.update:
          id: artist_title
          text: !lambda |-
            if (id(artist_count) > 0 && id(selected_artist) < id(artist_names).size()) {
              return id(artist_names)[id(selected_artist)].c_str();
            }
            return "Loading...";
      - lvgl.label.update:
          id: artist_subtitle
          text: !lambda |-
            static char buf[32];
            snprintf(buf, sizeof(buf), "%d / %d", id(selected_artist) + 1, id(artist_count));
            return buf;

  # Update ALBUMS screen with album list
  - id: update_album_display
    then:
      - lambda: |-
          std::string options = "";
          for (int i = 0; i < id(album_count); i++) {
            if (i > 0) options += "\n";
            options += id(filtered_album_names)[i];
          }
          if (options.empty()) {
            options = "No albums found";
          }
          lv_roller_set_options(id(album_roller)->obj, options.c_str(), LV_ROLLER_MODE_NORMAL);
          lv_roller_set_selected(id(album_roller)->obj, id(selected_album), LV_ANIM_ON);

  # Update PLAYER screen with current track
  - id: update_player_display
    then:
      - lvgl.label.update:
          id: track_title
          text: !lambda |-
            if (id(album_count) > 0 && id(selected_album) < id(filtered_album_names).size()) {
              return id(filtered_album_names)[id(selected_album)].c_str();
            }
            return "Unknown";
      - lvgl.label.update:
          id: play_icon
          text: !lambda |-
            if (id(is_playing)) {
              return "\uF04C";
            }
            return "\uF04B";

  # Music Assistant API: Play album
  - id: ma_play_album
    then:
      - http_request.post:
          url: "http://${ma_host}:${ma_port}/api"
          request_headers:
            Content-Type: "application/json"
            Authorization: "Bearer ${ma_token}"
          body: !lambda |-
            std::string uri = "";
            if (id(selected_album) < id(filtered_album_uris).size()) {
              uri = id(filtered_album_uris)[id(selected_album)];
            }
            return "{\"command\":\"player_queues/play_media\",\"args\":{\"queue_id\":\"${ma_player}\",\"media\":\"" + uri + "\",\"option\":\"replace\"}}";
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("ma", "Play album response: %d", response->status_code);

  # Music Assistant API: Pause
  - id: ma_pause
    then:
      - http_request.post:
          url: "http://${ma_host}:${ma_port}/api"
          request_headers:
            Content-Type: "application/json"
            Authorization: "Bearer ${ma_token}"
          body: '{"command":"player_queues/pause","args":{"queue_id":"${ma_player}"}}'
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("ma", "Pause response: %d", response->status_code);

  # Music Assistant API: Resume/Play
  - id: ma_resume
    then:
      - http_request.post:
          url: "http://${ma_host}:${ma_port}/api"
          request_headers:
            Content-Type: "application/json"
            Authorization: "Bearer ${ma_token}"
          body: '{"command":"player_queues/play","args":{"queue_id":"${ma_player}"}}'
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("ma", "Resume response: %d", response->status_code);

  # Music Assistant API: Stop
  - id: ma_stop
    then:
      - http_request.post:
          url: "http://${ma_host}:${ma_port}/api"
          request_headers:
            Content-Type: "application/json"
            Authorization: "Bearer ${ma_token}"
          body: '{"command":"player_queues/stop","args":{"queue_id":"${ma_player}"}}'
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("ma", "Stop response: %d", response->status_code);

  # Music Assistant API: Set Volume
  - id: ma_set_volume
    then:
      - http_request.post:
          url: "http://${ma_host}:${ma_port}/api"
          request_headers:
            Content-Type: "application/json"
            Authorization: "Bearer ${ma_token}"
          body: !lambda |-
            return "{\"command\":\"players/cmd/volume_set\",\"args\":{\"player_id\":\"${ma_player}\",\"volume_level\":" + std::to_string(id(current_volume)) + "}}";
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("ma", "Volume response: %d", response->status_code);

  # LED Feedback: Show position (1-5 LEDs based on index)
  - id: led_show_position
    then:
      - light.addressable_set:
          id: rgb_leds
          range_from: 0
          range_to: 4
          red: 0%
          green: 0%
          blue: 20%
      - lambda: |-
          int pos = 0;
          int count = 1;
          if (id(current_screen) == 0) {
            pos = id(selected_artist);
            count = id(artist_count);
          } else if (id(current_screen) == 1) {
            pos = id(selected_album);
            count = id(album_count);
          }
          // Map position to LED (0-4)
          int led = (count > 0) ? (pos * 5 / count) : 0;
          led = std::min(led, 4);
          auto call = id(rgb_leds).make_call();
          call.set_state(true);
          call.perform();
      - light.addressable_set:
          id: rgb_leds
          range_from: !lambda |-
            int pos = (id(current_screen) == 0) ? id(selected_artist) : id(selected_album);
            int count = (id(current_screen) == 0) ? id(artist_count) : id(album_count);
            return (count > 0) ? std::min(pos * 5 / count, 4) : 0;
          range_to: !lambda |-
            int pos = (id(current_screen) == 0) ? id(selected_artist) : id(selected_album);
            int count = (id(current_screen) == 0) ? id(artist_count) : id(album_count);
            return (count > 0) ? std::min(pos * 5 / count, 4) : 0;
          red: 0%
          green: 100%
          blue: 0%

  # LED Feedback: Playing state - green pulsing
  - id: led_playing
    then:
      - light.turn_on:
          id: rgb_leds
          brightness: 80%
          red: 0%
          green: 100%
          blue: 0%
          effect: "Playing Pulse"

  # LED Feedback: Paused state - dim green
  - id: led_paused
    then:
      - light.turn_on:
          id: rgb_leds
          brightness: 30%
          red: 0%
          green: 100%
          blue: 0%
          effect: "none"

  # LED Feedback: Volume indicator (fill LEDs based on volume)
  - id: led_show_volume
    then:
      - light.addressable_set:
          id: rgb_leds
          range_from: 0
          range_to: 4
          red: 0%
          green: 0%
          blue: 0%
      - light.addressable_set:
          id: rgb_leds
          range_from: 0
          range_to: !lambda 'return (id(current_volume) / 20);'
          red: 0%
          green: 100%
          blue: 0%

  # LED Feedback: Idle/boot - soft blue
  - id: led_idle
    then:
      - light.turn_on:
          id: rgb_leds
          brightness: 30%
          red: 0%
          green: 0%
          blue: 100%
          effect: "none"

# ============================================
# Display with LVGL
# ============================================

display:
  - platform: ili9xxx
    model: GC9A01A
    id: main_display
    cs_pin: GPIO9
    dc_pin: GPIO3
    reset_pin: GPIO14
    dimensions:
      width: 240
      height: 240
    rotation: 0
    invert_colors: true
    data_rate: 40MHz
    auto_clear_enabled: false

# LVGL Configuration
lvgl:
  displays:
    - main_display
  touchscreens: []
  color_depth: 16
  buffer_size: 25%
  log_level: WARN
  page_wrap: true
  pages:
    # Home Screen - Artist Selection
    - id: page_home
      bg_color: 0x1a1a2e
      widgets:
        - obj:
            align: CENTER
            width: 220
            height: 220
            radius: 110
            bg_color: 0x16213e
            border_width: 3
            border_color: 0x1DB954
            widgets:
              - label:
                  id: artist_title
                  align: CENTER
                  y: -20
                  text: "Loading..."
                  text_font: linda_font_24
                  text_color: 0xFFFFFF
              - label:
                  id: artist_subtitle
                  align: CENTER
                  y: 20
                  text: ""
                  text_font: linda_font_16
                  text_color: 0xB3B3B3
              - label:
                  align: BOTTOM_MID
                  y: -20
                  text: "Click to open"
                  text_font: linda_font_14
                  text_color: 0x666666

    # Albums List Screen
    - id: page_albums
      bg_color: 0x1a1a2e
      widgets:
        - obj:
            align: CENTER
            width: 220
            height: 220
            radius: 110
            bg_color: 0x16213e
            border_width: 2
            border_color: 0x1DB954
            widgets:
              - label:
                  align: TOP_MID
                  y: 20
                  text: "Albums"
                  text_font: linda_font_18
                  text_color: 0x1DB954
              - roller:
                  id: album_roller
                  align: CENTER
                  width: 180
                  height: 120
                  options:
                    - "Loading..."
                  visible_row_count: 3
                  text_font: linda_font_16

    # Now Playing Screen
    - id: page_player
      bg_color: 0x1a1a2e
      widgets:
        - arc:
            id: volume_arc
            align: CENTER
            width: 230
            height: 230
            arc_width: 8
            start_angle: 135
            end_angle: 45
            value: 50
            min_value: 0
            max_value: 100
            arc_color: 0x16213e
            indicator:
              arc_color: 0x1DB954
        - obj:
            align: CENTER
            width: 100
            height: 100
            radius: 50
            bg_color: 0x16213e
            widgets:
              - label:
                  id: play_icon
                  align: CENTER
                  text: "\uF04B"
                  text_font: linda_font_32
                  text_color: 0xFFFFFF
        - label:
            id: track_title
            align: CENTER
            y: 70
            text: "Loading..."
            text_font: linda_font_16
            text_color: 0xFFFFFF
        - bar:
            id: progress_bar
            align: CENTER
            y: 95
            width: 160
            height: 6
            value: 0
            min_value: 0
            max_value: 100
            bg_color: 0x16213e
            indicator:
              bg_color: 0x1DB954

font:
  - file: "gfonts://Montserrat"
    id: linda_font_14
    size: 14
    bpp: 4
    glyphsets:
      - GF_Latin_Kernel
      - GF_Latin_Core
  - file: "gfonts://Montserrat"
    id: linda_font_16
    size: 16
    bpp: 4
    glyphsets:
      - GF_Latin_Kernel
      - GF_Latin_Core
  - file: "gfonts://Montserrat"
    id: linda_font_18
    size: 18
    bpp: 4
    glyphsets:
      - GF_Latin_Kernel
      - GF_Latin_Core
  - file: "gfonts://Montserrat"
    id: linda_font_24
    size: 24
    bpp: 4
    glyphsets:
      - GF_Latin_Kernel
      - GF_Latin_Core
  - file: "gfonts://Montserrat"
    id: linda_font_32
    size: 32
    bpp: 4
    glyphsets:
      - GF_Latin_Kernel
      - GF_Latin_Core
